"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spinalEnvViewerGraphService = require("spinal-env-viewer-graph-service");

var _spinalModelsBuildingElements = require("spinal-models-building-elements");

var _constants = require("./constants");

var constants = _interopRequireWildcard(_constants);

var _spinalCoreConnectorjs_type = require("spinal-core-connectorjs_type");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// import bimobjService from 'spinal-env-viewer-plugin-bimobjectservice';

const bimobjService = window.spinal.BimObjectService;

const GeographicContext = {
  constants: constants,

  /**
   * Returns the child type of the type given as parameter.
   * @param {string} parentType
   * @return {string} Child type
   */
  getChildType(parentType) {
    let parentTypeIndex = constants.GEOGRAPHIC_TYPES_ORDER.indexOf(parentType);

    if (parentTypeIndex === -1) {
      return "";
    }

    return constants.GEOGRAPHIC_TYPES_ORDER[parentTypeIndex + 1];
  },

  /**
   * It Takes as parameter a context name, returns true if a context with the same name does not exist, else returns false.
   * @param {string} contextName
   * @returns {Boolean}
   */
  createContext(contextName) {
    if (typeof contextName !== "string") {
      throw Error("contextName must be a string");
    }

    const context = _spinalEnvViewerGraphService.SpinalGraphService.getContext(contextName);

    if (typeof context !== "undefined") return false;

    _spinalEnvViewerGraphService.SpinalGraphService.addContext(contextName, constants.CONTEXT_TYPE, new _spinalModelsBuildingElements.AbstractElement(contextName));

    return true;
  },

  /**
   * This method takes as parameters a context (SpinalContext), a parent node (must be a SpinalNode) and a string representing the abstract element type;
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {string} elementName - The AbstactElement Name
   * @returns {Boolean}
   */
  addAbstractElement(context, node, elementName) {
    const parentType = node.type.get();
    const childType = this.getChildType(parentType);

    if (!childType) {
      throw Error(`${parentType} is not a valid type in geographical context`);
    }

    const childRelation = constants.MAP_TYPE_RELATION.get(childType);

    const childNode = _spinalEnvViewerGraphService.SpinalGraphService.createNode({
      name: elementName,
      type: childType
    }, new _spinalModelsBuildingElements.AbstractElement(elementName));
    _spinalEnvViewerGraphService.SpinalGraphService.addChildInContext(node.id.get(), childNode, context.id.get(), childRelation, _spinalEnvViewerGraphService.SPINAL_RELATION_TYPE);

    this.addToReferenceContext(childNode);

    return true;
  },

  /**
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {string} buildingName - Building Name
   */
  addBuilding(context, node, buildingName) {
    return GeographicContext.addAbstractElement(context, node, buildingName);
  },

  /**
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {string} floorName - the floor Name
   */
  addFloor(context, node, floorName) {
    return GeographicContext.addAbstractElement(context, node, floorName);
  },

  /**
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {string} zoneName - Zone name
   */
  addZone(context, node, zoneName) {
    return GeographicContext.addAbstractElement(context, node, zoneName);
  },

  /**
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {string} roomName - Room Name
   */
  addRoom(context, node, roomName) {
    return GeographicContext.addAbstractElement(context, node, roomName);
  },

  /**
   * it uses bimObject service to add all dbIds passed as parameters.
   * the parameter dbIds can be a simple dbIds or a list of dbIds.
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {Number | Array<Number>} dbIds - Can be
   */
  addBimElement(context, node, dbIds, model) {

    if (!Array.isArray(dbIds)) dbIds = [dbIds];

    // le bimObjectService
    // let c = SpinalGraphService.getRealNode(context.id.get());
    // let n = SpinalGraphService.getRealNode(node.id.get());

    let contextId = context.id.get();
    let parentId = node.id.get();

    dbIds.forEach(element => {
      // bimobjService.addBIMObject(c, n, element.dbId, element.name);
      bimobjService.addBIMObject(contextId, parentId, element.dbId, element.name, model);
    });
  },

  _getReferenceContextName(nodeId) {
    let node = _spinalEnvViewerGraphService.SpinalGraphService.getInfo(nodeId);

    switch (node.type.get()) {
      case constants.SITE_TYPE:
        return {
          name: constants.SITE_REFERENCE_CONTEXT,
          relation: constants.SITE_RELATION
        };
      case constants.BUILDING_TYPE:
        return {
          name: constants.BUILDING_REFERENCE_CONTEXT,
          relation: constants.BUILDING_RELATION
        };

      case constants.FLOOR_TYPE:
        return {
          name: constants.FLOOR_REFERENCE_CONTEXT,
          relation: constants.FLOOR_RELATION
        };

      case constants.ZONE_TYPE:
        return {
          name: constants.ZONE_REFERENCE_CONTEXT,
          relation: constants.ZONE_RELATION
        };

      case constants.ROOM_TYPE:
        return {
          name: constants.ROOM_REFERENCE_CONTEXT,
          relation: constants.ROOM_RELATION
        };

      default:
        return undefined;
    }
  },

  /**
   *
   * @param {string} nodeId
   */
  addToReferenceContext(nodeId) {
    let obj = this._getReferenceContextName(nodeId);

    if (typeof obj !== "undefined") {
      let context = _spinalEnvViewerGraphService.SpinalGraphService.getContext(obj.name);

      if (typeof context !== "undefined") {

        return _spinalEnvViewerGraphService.SpinalGraphService.addChild(context.info.id.get(), nodeId, obj.relation, _spinalEnvViewerGraphService.SPINAL_RELATION_LST_PTR_TYPE);
      }

      return _spinalEnvViewerGraphService.SpinalGraphService.addContext(obj.name, obj.name.replace(".", ""), new _spinalCoreConnectorjs_type.Model({
        name: obj.name
      })).then(c => {
        return _spinalEnvViewerGraphService.SpinalGraphService.addChild(c.info.id.get(), nodeId, obj.relation, _spinalEnvViewerGraphService.SPINAL_RELATION_LST_PTR_TYPE);
      });
    }
  },

  /**
   *
   * @param {string} contextId
   */
  addContextToReference(contextId) {
    let context = _spinalEnvViewerGraphService.SpinalGraphService.getRealNode(contextId);

    if (typeof context !== "undefined") {
      return context.forEach(constants.GEOGRAPHIC_RELATIONS, node => {
        _spinalEnvViewerGraphService.SpinalGraphService._addNode(node);
        this.addToReferenceContext(node.info.id.get());
      });
    }
  }

};

exports.default = GeographicContext;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJjb25zdGFudHMiLCJiaW1vYmpTZXJ2aWNlIiwid2luZG93Iiwic3BpbmFsIiwiQmltT2JqZWN0U2VydmljZSIsIkdlb2dyYXBoaWNDb250ZXh0IiwiZ2V0Q2hpbGRUeXBlIiwicGFyZW50VHlwZSIsInBhcmVudFR5cGVJbmRleCIsIkdFT0dSQVBISUNfVFlQRVNfT1JERVIiLCJpbmRleE9mIiwiY3JlYXRlQ29udGV4dCIsImNvbnRleHROYW1lIiwiRXJyb3IiLCJjb250ZXh0IiwiU3BpbmFsR3JhcGhTZXJ2aWNlIiwiZ2V0Q29udGV4dCIsImFkZENvbnRleHQiLCJDT05URVhUX1RZUEUiLCJBYnN0cmFjdEVsZW1lbnQiLCJhZGRBYnN0cmFjdEVsZW1lbnQiLCJub2RlIiwiZWxlbWVudE5hbWUiLCJ0eXBlIiwiZ2V0IiwiY2hpbGRUeXBlIiwiY2hpbGRSZWxhdGlvbiIsIk1BUF9UWVBFX1JFTEFUSU9OIiwiY2hpbGROb2RlIiwiY3JlYXRlTm9kZSIsIm5hbWUiLCJhZGRDaGlsZEluQ29udGV4dCIsImlkIiwiU1BJTkFMX1JFTEFUSU9OX1RZUEUiLCJhZGRUb1JlZmVyZW5jZUNvbnRleHQiLCJhZGRCdWlsZGluZyIsImJ1aWxkaW5nTmFtZSIsImFkZEZsb29yIiwiZmxvb3JOYW1lIiwiYWRkWm9uZSIsInpvbmVOYW1lIiwiYWRkUm9vbSIsInJvb21OYW1lIiwiYWRkQmltRWxlbWVudCIsImRiSWRzIiwibW9kZWwiLCJBcnJheSIsImlzQXJyYXkiLCJjb250ZXh0SWQiLCJwYXJlbnRJZCIsImZvckVhY2giLCJlbGVtZW50IiwiYWRkQklNT2JqZWN0IiwiZGJJZCIsIl9nZXRSZWZlcmVuY2VDb250ZXh0TmFtZSIsIm5vZGVJZCIsImdldEluZm8iLCJTSVRFX1RZUEUiLCJTSVRFX1JFRkVSRU5DRV9DT05URVhUIiwicmVsYXRpb24iLCJTSVRFX1JFTEFUSU9OIiwiQlVJTERJTkdfVFlQRSIsIkJVSUxESU5HX1JFRkVSRU5DRV9DT05URVhUIiwiQlVJTERJTkdfUkVMQVRJT04iLCJGTE9PUl9UWVBFIiwiRkxPT1JfUkVGRVJFTkNFX0NPTlRFWFQiLCJGTE9PUl9SRUxBVElPTiIsIlpPTkVfVFlQRSIsIlpPTkVfUkVGRVJFTkNFX0NPTlRFWFQiLCJaT05FX1JFTEFUSU9OIiwiUk9PTV9UWVBFIiwiUk9PTV9SRUZFUkVOQ0VfQ09OVEVYVCIsIlJPT01fUkVMQVRJT04iLCJ1bmRlZmluZWQiLCJvYmoiLCJhZGRDaGlsZCIsImluZm8iLCJTUElOQUxfUkVMQVRJT05fTFNUX1BUUl9UWVBFIiwicmVwbGFjZSIsIk1vZGVsIiwidGhlbiIsImMiLCJhZGRDb250ZXh0VG9SZWZlcmVuY2UiLCJnZXRSZWFsTm9kZSIsIkdFT0dSQVBISUNfUkVMQVRJT05TIiwiX2FkZE5vZGUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUtBOztBQVFBOztJQUFZQSxTOztBQUNaOzs7O0FBTEE7O0FBRUEsTUFBTUMsZ0JBQWdCQyxPQUFPQyxNQUFQLENBQWNDLGdCQUFwQzs7QUFPQSxNQUFNQyxvQkFBb0I7QUFDeEJMLGFBQVdBLFNBRGE7O0FBR3hCOzs7OztBQUtBTSxlQUFhQyxVQUFiLEVBQXlCO0FBQ3ZCLFFBQUlDLGtCQUFrQlIsVUFBVVMsc0JBQVYsQ0FBaUNDLE9BQWpDLENBQ3BCSCxVQURvQixDQUF0Qjs7QUFHQSxRQUFJQyxvQkFBb0IsQ0FBQyxDQUF6QixFQUE0QjtBQUMxQixhQUFPLEVBQVA7QUFDRDs7QUFFRCxXQUFPUixVQUFVUyxzQkFBVixDQUFpQ0Qsa0JBQWtCLENBQW5ELENBQVA7QUFDRCxHQWpCdUI7O0FBbUJ4Qjs7Ozs7QUFLQUcsZ0JBQWNDLFdBQWQsRUFBMkI7QUFDekIsUUFBSSxPQUFPQSxXQUFQLEtBQXVCLFFBQTNCLEVBQXFDO0FBQ25DLFlBQU1DLE1BQ0osOEJBREksQ0FBTjtBQUVEOztBQUVELFVBQU1DLFVBQVVDLGdEQUFtQkMsVUFBbkIsQ0FBOEJKLFdBQTlCLENBQWhCOztBQUVBLFFBQUksT0FBT0Us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LEdBQWhCLEVBQTVCLEVBQW1EK0IsTUFBbkQsRUFDTG1CLElBQUlmLFFBREMsRUFFTGtCLHlEQUZLLENBQVA7QUFHRDs7QUFFRCxhQUFPOUQsZ0RBQW1CRSxVQUFuQixDQUE4QnlELElBQUk1QyxJQUFsQyxFQUF3QzRDLElBQUk1QyxJQUFKLENBQVNnRCxPQUFULENBQzdDLEdBRDZDLEVBQ3hDLEVBRHdDLENBQXhDLEVBQ0ssSUFBSUMsaUNBQUosQ0FBVTtBQUNwQmpELGNBQU00QyxJQUFJNUM7QUFEVSxPQUFWLENBREwsRUFHSGtELElBSEcsQ0FHRUMsS0FBSztBQUNaLGVBQU9sRSxnREFBbUI0RCxRQUFuQixDQUE0Qk0sRUFBRUwsSUFBRixDQUFPNUMsRUFBUCxDQUFVUixHQUFWLEVBQTVCLEVBQTZDK0IsTUFBN0MsRUFDTG1CLElBQUlmLFFBREMsRUFFTGtCLHlEQUZLLENBQVA7QUFHRCxPQVBNLENBQVA7QUFVRDtBQUVGLEdBaE51Qjs7QUFrTnhCOzs7O0FBSUFLLHdCQUFzQmxDLFNBQXRCLEVBQWlDO0FBQy9CLFFBQUlsQyxVQUFVQyxnREFBbUJvRSxXQUFuQixDQUErQm5DLFNBQS9CLENBQWQ7O0FBRUEsUUFBSSxPQUFPbEMsT0FBUCxLQUFtQixXQUF2QixFQUFvQztBQUNsQyxhQUFPQSxRQUFRb0MsT0FBUixDQUFnQmxELFVBQVVvRixvQkFBMUIsRUFBaUQvRCxJQUFELElBQVU7QUFDL0ROLHdEQUFtQnNFLFFBQW5CLENBQTRCaEUsSUFBNUI7QUFDQSxhQUFLYSxxQkFBTCxDQUEyQmIsS0FBS3VELElBQUwsQ0FBVTVDLEVBQVYsQ0FBYVIsR0FBYixFQUEzQjtBQUNELE9BSE0sQ0FBUDtBQUlEO0FBRUY7O0FBaE91QixDQUExQjs7a0JBb09lbkIsaUIiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBTUElOQUxfUkVMQVRJT05fVFlQRSxcbiAgU1BJTkFMX1JFTEFUSU9OX0xTVF9QVFJfVFlQRSxcbiAgU3BpbmFsR3JhcGhTZXJ2aWNlXG59IGZyb20gXCJzcGluYWwtZW52LXZpZXdlci1ncmFwaC1zZXJ2aWNlXCI7XG5pbXBvcnQge1xuICBBYnN0cmFjdEVsZW1lbnRcbn0gZnJvbSBcInNwaW5hbC1tb2RlbHMtYnVpbGRpbmctZWxlbWVudHNcIjtcblxuLy8gaW1wb3J0IGJpbW9ialNlcnZpY2UgZnJvbSAnc3BpbmFsLWVudi12aWV3ZXItcGx1Z2luLWJpbW9iamVjdHNlcnZpY2UnO1xuXG5jb25zdCBiaW1vYmpTZXJ2aWNlID0gd2luZG93LnNwaW5hbC5CaW1PYmplY3RTZXJ2aWNlO1xuXG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5pbXBvcnQge1xuICBNb2RlbFxufSBmcm9tIFwic3BpbmFsLWNvcmUtY29ubmVjdG9yanNfdHlwZVwiO1xuXG5jb25zdCBHZW9ncmFwaGljQ29udGV4dCA9IHtcbiAgY29uc3RhbnRzOiBjb25zdGFudHMsXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNoaWxkIHR5cGUgb2YgdGhlIHR5cGUgZ2l2ZW4gYXMgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50VHlwZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENoaWxkIHR5cGVcbiAgICovXG4gIGdldENoaWxkVHlwZShwYXJlbnRUeXBlKSB7XG4gICAgbGV0IHBhcmVudFR5cGVJbmRleCA9IGNvbnN0YW50cy5HRU9HUkFQSElDX1RZUEVTX09SREVSLmluZGV4T2YoXG4gICAgICBwYXJlbnRUeXBlKTtcblxuICAgIGlmIChwYXJlbnRUeXBlSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uc3RhbnRzLkdFT0dSQVBISUNfVFlQRVNfT1JERVJbcGFyZW50VHlwZUluZGV4ICsgMV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEl0IFRha2VzIGFzIHBhcmFtZXRlciBhIGNvbnRleHQgbmFtZSwgcmV0dXJucyB0cnVlIGlmIGEgY29udGV4dCB3aXRoIHRoZSBzYW1lIG5hbWUgZG9lcyBub3QgZXhpc3QsIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHROYW1lXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgY3JlYXRlQ29udGV4dChjb250ZXh0TmFtZSkge1xuICAgIGlmICh0eXBlb2YgY29udGV4dE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBcImNvbnRleHROYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGV4dCA9IFNwaW5hbEdyYXBoU2VydmljZS5nZXRDb250ZXh0KGNvbnRleHROYW1lKTtcblxuICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuXG5cbiAgICBTcGluYWxHcmFwaFNlcnZpY2UuYWRkQ29udGV4dChjb250ZXh0TmFtZSxcbiAgICAgIGNvbnN0YW50cy5DT05URVhUX1RZUEUsXG4gICAgICBuZXcgQWJzdHJhY3RFbGVtZW50KGNvbnRleHROYW1lKSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgdGFrZXMgYXMgcGFyYW1ldGVycyBhIGNvbnRleHQgKFNwaW5hbENvbnRleHQpLCBhIHBhcmVudCBub2RlIChtdXN0IGJlIGEgU3BpbmFsTm9kZSkgYW5kIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYWJzdHJhY3QgZWxlbWVudCB0eXBlO1xuICAgKiBAcGFyYW0ge1NwaW5hbENvbnRleHR9IGNvbnRleHQgLSBUaGUgQ29udGV4dCBnZW9ncmFwaGljXG4gICAqIEBwYXJhbSB7U3BpbmFsTm9kZX0gbm9kZSAtIFRoZSBwYXJlbnQgTm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWUgLSBUaGUgQWJzdGFjdEVsZW1lbnQgTmFtZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGFkZEFic3RyYWN0RWxlbWVudChjb250ZXh0LCBub2RlLCBlbGVtZW50TmFtZSkge1xuICAgIGNvbnN0IHBhcmVudFR5cGUgPSBub2RlLnR5cGUuZ2V0KCk7XG4gICAgY29uc3QgY2hpbGRUeXBlID0gdGhpcy5nZXRDaGlsZFR5cGUocGFyZW50VHlwZSk7XG5cbiAgICBpZiAoIWNoaWxkVHlwZSkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGAke3BhcmVudFR5cGV9IGlzIG5vdCBhIHZhbGlkIHR5cGUgaW4gZ2VvZ3JhcGhpY2FsIGNvbnRleHRgXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkUmVsYXRpb24gPSBjb25zdGFudHMuTUFQX1RZUEVfUkVMQVRJT04uZ2V0KGNoaWxkVHlwZSk7XG5cbiAgICBjb25zdCBjaGlsZE5vZGUgPSBTcGluYWxHcmFwaFNlcnZpY2UuY3JlYXRlTm9kZSh7XG4gICAgICAgIG5hbWU6IGVsZW1lbnROYW1lLFxuICAgICAgICB0eXBlOiBjaGlsZFR5cGVcbiAgICAgIH0sXG4gICAgICBuZXcgQWJzdHJhY3RFbGVtZW50KGVsZW1lbnROYW1lKVxuICAgICk7XG4gICAgU3BpbmFsR3JhcGhTZXJ2aWNlLmFkZENoaWxkSW5Db250ZXh0KG5vZGUuaWQuZ2V0KCksIGNoaWxkTm9kZSwgY29udGV4dC5pZFxuICAgICAgLmdldCgpLCBjaGlsZFJlbGF0aW9uLCBTUElOQUxfUkVMQVRJT05fVFlQRSk7XG5cbiAgICB0aGlzLmFkZFRvUmVmZXJlbmNlQ29udGV4dChjaGlsZE5vZGUpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3BpbmFsQ29udGV4dH0gY29udGV4dCAtIFRoZSBDb250ZXh0IGdlb2dyYXBoaWNcbiAgICogQHBhcmFtIHtTcGluYWxOb2RlfSBub2RlIC0gVGhlIHBhcmVudCBOb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBidWlsZGluZ05hbWUgLSBCdWlsZGluZyBOYW1lXG4gICAqL1xuICBhZGRCdWlsZGluZyhjb250ZXh0LCBub2RlLCBidWlsZGluZ05hbWUpIHtcbiAgICByZXR1cm4gR2VvZ3JhcGhpY0NvbnRleHQuYWRkQWJzdHJhY3RFbGVtZW50KGNvbnRleHQsIG5vZGUsIGJ1aWxkaW5nTmFtZSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQHBhcmFtIHtTcGluYWxDb250ZXh0fSBjb250ZXh0IC0gVGhlIENvbnRleHQgZ2VvZ3JhcGhpY1xuICAgKiBAcGFyYW0ge1NwaW5hbE5vZGV9IG5vZGUgLSBUaGUgcGFyZW50IE5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZsb29yTmFtZSAtIHRoZSBmbG9vciBOYW1lXG4gICAqL1xuICBhZGRGbG9vcihjb250ZXh0LCBub2RlLCBmbG9vck5hbWUpIHtcbiAgICByZXR1cm4gR2VvZ3JhcGhpY0NvbnRleHQuYWRkQWJzdHJhY3RFbGVtZW50KGNvbnRleHQsIG5vZGUsIGZsb29yTmFtZSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQHBhcmFtIHtTcGluYWxDb250ZXh0fSBjb250ZXh0IC0gVGhlIENvbnRleHQgZ2VvZ3JhcGhpY1xuICAgKiBAcGFyYW0ge1NwaW5hbE5vZGV9IG5vZGUgLSBUaGUgcGFyZW50IE5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmVOYW1lIC0gWm9uZSBuYW1lXG4gICAqL1xuICBhZGRab25lKGNvbnRleHQsIG5vZGUsIHpvbmVOYW1lKSB7XG4gICAgcmV0dXJuIEdlb2dyYXBoaWNDb250ZXh0LmFkZEFic3RyYWN0RWxlbWVudChjb250ZXh0LCBub2RlLCB6b25lTmFtZSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQHBhcmFtIHtTcGluYWxDb250ZXh0fSBjb250ZXh0IC0gVGhlIENvbnRleHQgZ2VvZ3JhcGhpY1xuICAgKiBAcGFyYW0ge1NwaW5hbE5vZGV9IG5vZGUgLSBUaGUgcGFyZW50IE5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb21OYW1lIC0gUm9vbSBOYW1lXG4gICAqL1xuICBhZGRSb29tKGNvbnRleHQsIG5vZGUsIHJvb21OYW1lKSB7XG4gICAgcmV0dXJuIEdlb2dyYXBoaWNDb250ZXh0LmFkZEFic3RyYWN0RWxlbWVudChjb250ZXh0LCBub2RlLCByb29tTmFtZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGl0IHVzZXMgYmltT2JqZWN0IHNlcnZpY2UgdG8gYWRkIGFsbCBkYklkcyBwYXNzZWQgYXMgcGFyYW1ldGVycy5cbiAgICogdGhlIHBhcmFtZXRlciBkYklkcyBjYW4gYmUgYSBzaW1wbGUgZGJJZHMgb3IgYSBsaXN0IG9mIGRiSWRzLlxuICAgKiBAcGFyYW0ge1NwaW5hbENvbnRleHR9IGNvbnRleHQgLSBUaGUgQ29udGV4dCBnZW9ncmFwaGljXG4gICAqIEBwYXJhbSB7U3BpbmFsTm9kZX0gbm9kZSAtIFRoZSBwYXJlbnQgTm9kZVxuICAgKiBAcGFyYW0ge051bWJlciB8IEFycmF5PE51bWJlcj59IGRiSWRzIC0gQ2FuIGJlXG4gICAqL1xuICBhZGRCaW1FbGVtZW50KGNvbnRleHQsIG5vZGUsIGRiSWRzLCBtb2RlbCkge1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRiSWRzKSkgZGJJZHMgPSBbZGJJZHNdO1xuXG5cbiAgICAvLyBsZSBiaW1PYmplY3RTZXJ2aWNlXG4gICAgLy8gbGV0IGMgPSBTcGluYWxHcmFwaFNlcnZpY2UuZ2V0UmVhbE5vZGUoY29udGV4dC5pZC5nZXQoKSk7XG4gICAgLy8gbGV0IG4gPSBTcGluYWxHcmFwaFNlcnZpY2UuZ2V0UmVhbE5vZGUobm9kZS5pZC5nZXQoKSk7XG5cbiAgICBsZXQgY29udGV4dElkID0gY29udGV4dC5pZC5nZXQoKTtcbiAgICBsZXQgcGFyZW50SWQgPSBub2RlLmlkLmdldCgpO1xuXG4gICAgZGJJZHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIC8vIGJpbW9ialNlcnZpY2UuYWRkQklNT2JqZWN0KGMsIG4sIGVsZW1lbnQuZGJJZCwgZWxlbWVudC5uYW1lKTtcbiAgICAgIGJpbW9ialNlcnZpY2UuYWRkQklNT2JqZWN0KGNvbnRleHRJZCwgcGFyZW50SWQsIGVsZW1lbnQuZGJJZCxcbiAgICAgICAgZWxlbWVudC5uYW1lLCBtb2RlbClcbiAgICB9KTtcbiAgfSxcblxuXG4gIF9nZXRSZWZlcmVuY2VDb250ZXh0TmFtZShub2RlSWQpIHtcbiAgICBsZXQgbm9kZSA9IFNwaW5hbEdyYXBoU2VydmljZS5nZXRJbmZvKG5vZGVJZCk7XG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZS5nZXQoKSkge1xuICAgICAgY2FzZSBjb25zdGFudHMuU0lURV9UWVBFOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IGNvbnN0YW50cy5TSVRFX1JFRkVSRU5DRV9DT05URVhULFxuICAgICAgICAgICAgcmVsYXRpb246IGNvbnN0YW50cy5TSVRFX1JFTEFUSU9OXG4gICAgICAgIH07XG4gICAgICBjYXNlIGNvbnN0YW50cy5CVUlMRElOR19UWVBFOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IGNvbnN0YW50cy5CVUlMRElOR19SRUZFUkVOQ0VfQ09OVEVYVCxcbiAgICAgICAgICAgIHJlbGF0aW9uOiBjb25zdGFudHMuQlVJTERJTkdfUkVMQVRJT05cbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBjb25zdGFudHMuRkxPT1JfVFlQRTpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBjb25zdGFudHMuRkxPT1JfUkVGRVJFTkNFX0NPTlRFWFQsXG4gICAgICAgICAgICByZWxhdGlvbjogY29uc3RhbnRzLkZMT09SX1JFTEFUSU9OXG4gICAgICAgIH07XG5cbiAgICAgIGNhc2UgY29uc3RhbnRzLlpPTkVfVFlQRTpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBjb25zdGFudHMuWk9ORV9SRUZFUkVOQ0VfQ09OVEVYVCxcbiAgICAgICAgICAgIHJlbGF0aW9uOiBjb25zdGFudHMuWk9ORV9SRUxBVElPTlxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIGNvbnN0YW50cy5ST09NX1RZUEU6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogY29uc3RhbnRzLlJPT01fUkVGRVJFTkNFX0NPTlRFWFQsXG4gICAgICAgICAgICByZWxhdGlvbjogY29uc3RhbnRzLlJPT01fUkVMQVRJT05cbiAgICAgICAgfTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBub2RlSWRcbiAgICovXG4gIGFkZFRvUmVmZXJlbmNlQ29udGV4dChub2RlSWQpIHtcbiAgICBsZXQgb2JqID0gdGhpcy5fZ2V0UmVmZXJlbmNlQ29udGV4dE5hbWUobm9kZUlkKTtcblxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBsZXQgY29udGV4dCA9IFNwaW5hbEdyYXBoU2VydmljZS5nZXRDb250ZXh0KG9iai5uYW1lKTtcblxuICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cbiAgICAgICAgcmV0dXJuIFNwaW5hbEdyYXBoU2VydmljZS5hZGRDaGlsZChjb250ZXh0LmluZm8uaWQuZ2V0KCksIG5vZGVJZCxcbiAgICAgICAgICBvYmoucmVsYXRpb24sXG4gICAgICAgICAgU1BJTkFMX1JFTEFUSU9OX0xTVF9QVFJfVFlQRSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTcGluYWxHcmFwaFNlcnZpY2UuYWRkQ29udGV4dChvYmoubmFtZSwgb2JqLm5hbWUucmVwbGFjZShcbiAgICAgICAgXCIuXCIsIFwiXCIpLCBuZXcgTW9kZWwoe1xuICAgICAgICBuYW1lOiBvYmoubmFtZVxuICAgICAgfSkpLnRoZW4oYyA9PiB7XG4gICAgICAgIHJldHVybiBTcGluYWxHcmFwaFNlcnZpY2UuYWRkQ2hpbGQoYy5pbmZvLmlkLmdldCgpLCBub2RlSWQsXG4gICAgICAgICAgb2JqLnJlbGF0aW9uLFxuICAgICAgICAgIFNQSU5BTF9SRUxBVElPTl9MU1RfUFRSX1RZUEUpO1xuICAgICAgfSk7XG5cblxuICAgIH1cblxuICB9LFxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dElkXG4gICAqL1xuICBhZGRDb250ZXh0VG9SZWZlcmVuY2UoY29udGV4dElkKSB7XG4gICAgbGV0IGNvbnRleHQgPSBTcGluYWxHcmFwaFNlcnZpY2UuZ2V0UmVhbE5vZGUoY29udGV4dElkKTtcblxuICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIGNvbnRleHQuZm9yRWFjaChjb25zdGFudHMuR0VPR1JBUEhJQ19SRUxBVElPTlMsIChub2RlKSA9PiB7XG4gICAgICAgIFNwaW5hbEdyYXBoU2VydmljZS5fYWRkTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5hZGRUb1JlZmVyZW5jZUNvbnRleHQobm9kZS5pbmZvLmlkLmdldCgpKTtcbiAgICAgIH0pXG4gICAgfVxuXG4gIH1cblxufTtcblxuZXhwb3J0IGRlZmF1bHQgR2VvZ3JhcGhpY0NvbnRleHQ7Il19