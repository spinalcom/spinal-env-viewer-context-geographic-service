"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spinalEnvViewerGraphService = require("spinal-env-viewer-graph-service");

var _spinalModelsBuildingElements = require("spinal-models-building-elements");

var _spinalEnvViewerPluginBimobjectservice = require("spinal-env-viewer-plugin-bimobjectservice");

var _spinalEnvViewerPluginBimobjectservice2 = _interopRequireDefault(_spinalEnvViewerPluginBimobjectservice);

var _constants = require("./constants");

var constants = _interopRequireWildcard(_constants);

var _spinalCoreConnectorjs_type = require("spinal-core-connectorjs_type");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const GeographicContext = {
  constants: constants,

  /**
   * Returns the child type of the type given as parameter.
   * @param {string} parentType
   * @return {string} Child type
   */
  getChildType(parentType) {
    let parentTypeIndex = constants.GEOGRAPHIC_TYPES_ORDER.indexOf(parentType);

    if (parentTypeIndex === -1) {
      return "";
    }

    return constants.GEOGRAPHIC_TYPES_ORDER[parentTypeIndex + 1];
  },

  /**
   * It Takes as parameter a context name, returns true if a context with the same name does not exist, else returns false.
   * @param {string} contextName
   * @returns {Boolean}
   */
  createContext(contextName) {
    if (typeof contextName !== "string") {
      throw Error("contextName must be a string");
    }

    const context = _spinalEnvViewerGraphService.SpinalGraphService.getContext(contextName);

    if (typeof context !== "undefined") return false;

    _spinalEnvViewerGraphService.SpinalGraphService.addContext(contextName, constants.CONTEXT_TYPE, new _spinalModelsBuildingElements.AbstractElement(contextName));

    return true;
  },

  /**
   * This method takes as parameters a context (SpinalContext), a parent node (must be a SpinalNode) and a string representing the abstract element type;
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {string} elementName - The AbstactElement Name
   * @returns {Boolean}
   */
  addAbstractElement(context, node, elementName) {
    const parentType = node.type.get();
    const childType = this.getChildType(parentType);

    if (!childType) {
      throw Error(`${parentType} is not a valid type in geographical context`);
    }

    const childRelation = constants.MAP_TYPE_RELATION.get(childType);

    const childNode = _spinalEnvViewerGraphService.SpinalGraphService.createNode({
      name: elementName,
      type: childType
    }, new _spinalModelsBuildingElements.AbstractElement(elementName));
    _spinalEnvViewerGraphService.SpinalGraphService.addChildInContext(node.id.get(), childNode, context.id.get(), childRelation, _spinalEnvViewerGraphService.SPINAL_RELATION_TYPE);

    this.addToReferenceContext(childNode);

    return true;
  },

  /**
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {string} buildingName - Building Name
   */
  addBuilding(context, node, buildingName) {
    return GeographicContext.addAbstractElement(context, node, buildingName);
  },

  /**
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {string} floorName - the floor Name
   */
  addFloor(context, node, floorName) {
    return GeographicContext.addAbstractElement(context, node, floorName);
  },

  /**
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {string} zoneName - Zone name
   */
  addZone(context, node, zoneName) {
    return GeographicContext.addAbstractElement(context, node, zoneName);
  },

  /**
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {string} roomName - Room Name
   */
  addRoom(context, node, roomName) {
    return GeographicContext.addAbstractElement(context, node, roomName);
  },

  /**
   * it uses bimObject service to add all dbIds passed as parameters.
   * the parameter dbIds can be a simple dbIds or a list of dbIds.
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {Number | Array<Number>} dbIds - Can be
   */
  addBimElement(context, node, dbIds) {
    if (!Array.isArray(dbIds)) dbIds = [dbIds];

    // le bimObjectService
    let c = _spinalEnvViewerGraphService.SpinalGraphService.getRealNode(context.id.get());
    let n = _spinalEnvViewerGraphService.SpinalGraphService.getRealNode(node.id.get());

    dbIds.forEach(element => {
      _spinalEnvViewerPluginBimobjectservice2.default.addBIMObject(c, n, element.dbId, element.name);
    });
  },

  _getReferenceContextName(nodeId) {
    let node = _spinalEnvViewerGraphService.SpinalGraphService.getInfo(nodeId);

    switch (node.type.get()) {
      case constants.SITE_TYPE:
        return {
          name: constants.SITE_REFERENCE_CONTEXT,
          relation: constants.SITE_RELATION
        };
      case constants.BUILDING_TYPE:
        return {
          name: constants.BUILDING_REFERENCE_CONTEXT,
          relation: constants.BUILDING_RELATION
        };

      case constants.FLOOR_TYPE:
        return {
          name: constants.FLOOR_REFERENCE_CONTEXT,
          relation: constants.FLOOR_RELATION
        };

      case constants.ZONE_TYPE:
        return {
          name: constants.ZONE_REFERENCE_CONTEXT,
          relation: constants.ZONE_RELATION
        };

      case constants.ROOM_TYPE:
        return {
          name: constants.ROOM_REFERENCE_CONTEXT,
          relation: constants.ROOM_RELATION
        };

      default:
        return undefined;
    }
  },

  /**
   *
   * @param {string} nodeId
   */
  addToReferenceContext(nodeId) {
    let obj = this._getReferenceContextName(nodeId);

    if (typeof obj !== "undefined") {
      let context = _spinalEnvViewerGraphService.SpinalGraphService.getContext(obj.name);

      if (typeof context !== "undefined") {

        return _spinalEnvViewerGraphService.SpinalGraphService.addChild(context.info.id.get(), nodeId, obj.relation, _spinalEnvViewerGraphService.SPINAL_RELATION_LST_PTR_TYPE);
      }

      return _spinalEnvViewerGraphService.SpinalGraphService.addContext(obj.name, obj.name.replace(".", ""), new _spinalCoreConnectorjs_type.Model({
        name: obj.name
      })).then(c => {
        return _spinalEnvViewerGraphService.SpinalGraphService.addChild(c.info.id.get(), nodeId, obj.relation, _spinalEnvViewerGraphService.SPINAL_RELATION_LST_PTR_TYPE);
      });
    }
  },

  /**
   *
   * @param {string} contextId
   */
  addContextToReference(contextId) {
    let context = _spinalEnvViewerGraphService.SpinalGraphService.getRealNode(contextId);

    if (typeof context !== "undefined") {
      return context.forEach(constants.GEOGRAPHIC_RELATIONS, node => {
        _spinalEnvViewerGraphService.SpinalGraphService._addNode(node);
        this.addToReferenceContext(node.info.id.get());
      });
    }
  }

};

exports.default = GeographicContext;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJjb25zdGFudHMiLCJHZW9ncmFwaGljQ29udGV4dCIsImdldENoaWxkVHlwZSIsInBhcmVudFR5cGUiLCJwYXJlbnRUeXBlSW5kZXgiLCJHRU9HUkFQSElDX1RZUEVTX09SREVSIiwiaW5kZXhPZiIsImNyZWF0ZUNvbnRleHQiLCJjb250ZXh0TmFtZSIsIkVycm9yIiwiY29udGV4dCIsIlNwaW5hbEdyYXBoU2VydmljZSIsImdldENvbnRleHQiLCJhZGRDb250ZXh0IiwiQ09OVEVYVF9UWVBFIiwiQWJzdHJhY3RFbGVtZW50IiwiYWRkQWJzdHJhY3RFbGVtZW50Iiwibm9kZSIsImVsZW1lbnROYW1lIiwidHlwZSIsImdldCIsImNoaWxkVHlwZSIsImNoaWxkUmVsYXRpb24iLCJNQVBfVFlQRV9SRUxBVElPTiIsImNoaWxkTm9kZSIsImNyZWF0ZU5vZGUiLCJuYW1lIiwiYWRkQ2hpbGRJbkNvbnRleHQiLCJpZCIsIlNQSU5BTF9SRUxBVElPTl9UWVBFIiwiYWRkVG9SZWZlcmVuY2VDb250ZXh0IiwiYWRkQnVpbGRpbmciLCJidWlsZGluZ05hbWUiLCJhZGRGbG9vciIsImZsb29yTmFtZSIsImFkZFpvbmUiLCJ6b25lTmFtZSIsImFkZFJvb20iLCJyb29tTmFtZSIsImFkZEJpbUVsZW1lbnQiLCJkYklkcyIsIkFycmF5IiwiaXNBcnJheSIsImMiLCJnZXRSZWFsTm9kZSIsIm4iLCJmb3JFYWNoIiwiZWxlbWVudCIsImJpbW9ialNlcnZpY2UiLCJhZGRCSU1PYmplY3QiLCJkYklkIiwiX2dldFJlZmVyZW5jZUNvbnRleHROYW1lIiwibm9kZUlkIiwiZ2V0SW5mbyIsIlNJVEVfVFlQRSIsIlNJVEVfUkVGRVJFTkNFX0NPTlRFWFQiLCJyZWxhdGlvbiIsIlNJVEVfUkVMQVRJT04iLCJCVUlMRElOR19UWVBFIiwiQlVJTERJTkdfUkVGRVJFTkNFX0NPTlRFWFQiLCJCVUlMRElOR19SRUxBVElPTiIsIkZMT09SX1RZUEUiLCJGTE9PUl9SRUZFUkVOQ0VfQ09OVEVYVCIsIkZMT09SX1JFTEFUSU9OIiwiWk9ORV9UWVBFIiwiWk9ORV9SRUZFUkVOQ0VfQ09OVEVYVCIsIlpPTkVfUkVMQVRJT04iLCJST09NX1RZUEUiLCJST09NX1JFRkVSRU5DRV9DT05URVhUIiwiUk9PTV9SRUxBVElPTiIsInVuZGVmaW5lZCIsIm9iaiIsImFkZENoaWxkIiwiaW5mbyIsIlNQSU5BTF9SRUxBVElPTl9MU1RfUFRSX1RZUEUiLCJyZXBsYWNlIiwiTW9kZWwiLCJ0aGVuIiwiYWRkQ29udGV4dFRvUmVmZXJlbmNlIiwiY29udGV4dElkIiwiR0VPR1JBUEhJQ19SRUxBVElPTlMiLCJfYWRkTm9kZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0FBS0E7O0FBR0E7Ozs7QUFFQTs7SUFBWUEsUzs7QUFDWjs7Ozs7O0FBSUEsTUFBTUMsb0JBQW9CO0FBQ3hCRCxhQUFXQSxTQURhOztBQUd4Qjs7Ozs7QUFLQUUsZUFBYUMsVUFBYixFQUF5QjtBQUN2QixRQUFJQyxrQkFBa0JKLFVBQVVLLHNCQUFWLENBQWlDQyxPQUFqQyxDQUN0QkgsVUFEc0IsQ0FBdEI7O0FBR0EsUUFBSUMsb0JBQW9CLENBQUMsQ0FBekIsRUFBNEI7QUFDMUIsYUFBTyxFQUFQO0FBQ0Q7O0FBRUQsV0FBT0osVUFBVUssc0JBQVYsQ0FBaUNELGtCQUFrQixDQUFuRCxDQUFQO0FBQ0QsR0FqQnVCOztBQW1CeEI7Ozs7O0FBS0FHLGdCQUFjQyxXQUFkLEVBQTJCO0FBQ3pCLFFBQUksT0FBT0EsV0FBUCxLQUF1QixRQUEzQixFQUFxQztBQUNuQyxZQUFNQyxNQUNKLDhCQURJLENBQU47QUFFRDs7QUFFRCxVQUFNQyxVQUFVQyxnREFBbUJDLFVBQW5CLENBQThCSixXQUE5QixDQUFoQjs7QUFFQSxRQUFJLE9BQU9FLE9BQVAsS0FBbUIsV0FBdkIsRUFBb0MsT0FBTyxLQUFQOztBQUdwQ0Msb0RBQW1CRSxVQUFuQixDQUE4QkwsV0FBOUIsRUFDRVIsVUFBVWMsWUFEWixFQUVFLElB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QUFtQkUsVUFBbkIsQ0FBOEIwRCxJQUFJN0MsSUFBbEMsRUFBd0M2QyxJQUFJN0MsSUFBSixDQUFTaUQsT0FBVCxDQUM3QyxHQUQ2QyxFQUN4QyxFQUR3QyxDQUF4QyxFQUNLLElBQUlDLGlDQUFKLENBQVU7QUFDcEJsRCxjQUFNNkMsSUFBSTdDO0FBRFUsT0FBVixDQURMLEVBR0htRCxJQUhHLENBR0VsQyxLQUFLO0FBQ1osZUFBT2hDLGdEQUFtQjZELFFBQW5CLENBQTRCN0IsRUFBRThCLElBQUYsQ0FBTzdDLEVBQVAsQ0FBVVIsR0FBVixFQUE1QixFQUE2Q2dDLE1BQTdDLEVBQ0xtQixJQUFJZixRQURDLEVBRUxrQix5REFGSyxDQUFQO0FBR0QsT0FQTSxDQUFQO0FBVUQ7QUFFRixHQTFNdUI7O0FBNE14Qjs7OztBQUlBSSx3QkFBc0JDLFNBQXRCLEVBQWlDO0FBQy9CLFFBQUlyRSxVQUFVQyxnREFBbUJpQyxXQUFuQixDQUErQm1DLFNBQS9CLENBQWQ7O0FBRUEsUUFBSSxPQUFPckUsT0FBUCxLQUFtQixXQUF2QixFQUFvQztBQUNsQyxhQUFPQSxRQUFRb0MsT0FBUixDQUFnQjlDLFVBQVVnRixvQkFBMUIsRUFBaUQvRCxJQUFELElBQVU7QUFDL0ROLHdEQUFtQnNFLFFBQW5CLENBQTRCaEUsSUFBNUI7QUFDQSxhQUFLYSxxQkFBTCxDQUEyQmIsS0FBS3dELElBQUwsQ0FBVTdDLEVBQVYsQ0FBYVIsR0FBYixFQUEzQjtBQUNELE9BSE0sQ0FBUDtBQUlEO0FBRUY7O0FBMU51QixDQUExQjs7a0JBOE5lbkIsaUIiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBTUElOQUxfUkVMQVRJT05fVFlQRSxcbiAgU1BJTkFMX1JFTEFUSU9OX0xTVF9QVFJfVFlQRSxcbiAgU3BpbmFsR3JhcGhTZXJ2aWNlXG59IGZyb20gXCJzcGluYWwtZW52LXZpZXdlci1ncmFwaC1zZXJ2aWNlXCI7XG5pbXBvcnQge1xuICBBYnN0cmFjdEVsZW1lbnRcbn0gZnJvbSBcInNwaW5hbC1tb2RlbHMtYnVpbGRpbmctZWxlbWVudHNcIjtcbmltcG9ydCBiaW1vYmpTZXJ2aWNlIGZyb20gJ3NwaW5hbC1lbnYtdmlld2VyLXBsdWdpbi1iaW1vYmplY3RzZXJ2aWNlJztcblxuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gXCIuL2NvbnN0YW50c1wiO1xuaW1wb3J0IHtcbiAgTW9kZWxcbn0gZnJvbSBcInNwaW5hbC1jb3JlLWNvbm5lY3RvcmpzX3R5cGVcIjtcblxuY29uc3QgR2VvZ3JhcGhpY0NvbnRleHQgPSB7XG4gIGNvbnN0YW50czogY29uc3RhbnRzLFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaGlsZCB0eXBlIG9mIHRoZSB0eXBlIGdpdmVuIGFzIHBhcmFtZXRlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudFR5cGVcbiAgICogQHJldHVybiB7c3RyaW5nfSBDaGlsZCB0eXBlXG4gICAqL1xuICBnZXRDaGlsZFR5cGUocGFyZW50VHlwZSkge1xuICAgIGxldCBwYXJlbnRUeXBlSW5kZXggPSBjb25zdGFudHMuR0VPR1JBUEhJQ19UWVBFU19PUkRFUi5pbmRleE9mKFxuICAgIHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKHBhcmVudFR5cGVJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cblxuICAgIHJldHVybiBjb25zdGFudHMuR0VPR1JBUEhJQ19UWVBFU19PUkRFUltwYXJlbnRUeXBlSW5kZXggKyAxXTtcbiAgfSxcblxuICAvKipcbiAgICogSXQgVGFrZXMgYXMgcGFyYW1ldGVyIGEgY29udGV4dCBuYW1lLCByZXR1cm5zIHRydWUgaWYgYSBjb250ZXh0IHdpdGggdGhlIHNhbWUgbmFtZSBkb2VzIG5vdCBleGlzdCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dE5hbWVcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBjcmVhdGVDb250ZXh0KGNvbnRleHROYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0TmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiY29udGV4dE5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZXh0ID0gU3BpbmFsR3JhcGhTZXJ2aWNlLmdldENvbnRleHQoY29udGV4dE5hbWUpO1xuXG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG5cblxuICAgIFNwaW5hbEdyYXBoU2VydmljZS5hZGRDb250ZXh0KGNvbnRleHROYW1lLFxuICAgICAgY29uc3RhbnRzLkNPTlRFWFRfVFlQRSxcbiAgICAgIG5ldyBBYnN0cmFjdEVsZW1lbnQoY29udGV4dE5hbWUpKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBhcyBwYXJhbWV0ZXJzIGEgY29udGV4dCAoU3BpbmFsQ29udGV4dCksIGEgcGFyZW50IG5vZGUgKG11c3QgYmUgYSBTcGluYWxOb2RlKSBhbmQgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBhYnN0cmFjdCBlbGVtZW50IHR5cGU7XG4gICAqIEBwYXJhbSB7U3BpbmFsQ29udGV4dH0gY29udGV4dCAtIFRoZSBDb250ZXh0IGdlb2dyYXBoaWNcbiAgICogQHBhcmFtIHtTcGluYWxOb2RlfSBub2RlIC0gVGhlIHBhcmVudCBOb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZSAtIFRoZSBBYnN0YWN0RWxlbWVudCBOYW1lXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgYWRkQWJzdHJhY3RFbGVtZW50KGNvbnRleHQsIG5vZGUsIGVsZW1lbnROYW1lKSB7XG4gICAgY29uc3QgcGFyZW50VHlwZSA9IG5vZGUudHlwZS5nZXQoKTtcbiAgICBjb25zdCBjaGlsZFR5cGUgPSB0aGlzLmdldENoaWxkVHlwZShwYXJlbnRUeXBlKTtcblxuICAgIGlmICghY2hpbGRUeXBlKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYCR7cGFyZW50VHlwZX0gaXMgbm90IGEgdmFsaWQgdHlwZSBpbiBnZW9ncmFwaGljYWwgY29udGV4dGBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgY2hpbGRSZWxhdGlvbiA9IGNvbnN0YW50cy5NQVBfVFlQRV9SRUxBVElPTi5nZXQoY2hpbGRUeXBlKTtcblxuICAgIGNvbnN0IGNoaWxkTm9kZSA9IFNwaW5hbEdyYXBoU2VydmljZS5jcmVhdGVOb2RlKHtcbiAgICAgICAgbmFtZTogZWxlbWVudE5hbWUsXG4gICAgICAgIHR5cGU6IGNoaWxkVHlwZVxuICAgICAgfSxcbiAgICAgIG5ldyBBYnN0cmFjdEVsZW1lbnQoZWxlbWVudE5hbWUpXG4gICAgKTtcbiAgICBTcGluYWxHcmFwaFNlcnZpY2UuYWRkQ2hpbGRJbkNvbnRleHQobm9kZS5pZC5nZXQoKSwgY2hpbGROb2RlLCBjb250ZXh0LmlkXG4gICAgICAuZ2V0KCksIGNoaWxkUmVsYXRpb24sIFNQSU5BTF9SRUxBVElPTl9UWVBFKTtcblxuICAgIHRoaXMuYWRkVG9SZWZlcmVuY2VDb250ZXh0KGNoaWxkTm9kZSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtTcGluYWxDb250ZXh0fSBjb250ZXh0IC0gVGhlIENvbnRleHQgZ2VvZ3JhcGhpY1xuICAgKiBAcGFyYW0ge1NwaW5hbE5vZGV9IG5vZGUgLSBUaGUgcGFyZW50IE5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJ1aWxkaW5nTmFtZSAtIEJ1aWxkaW5nIE5hbWVcbiAgICovXG4gIGFkZEJ1aWxkaW5nKGNvbnRleHQsIG5vZGUsIGJ1aWxkaW5nTmFtZSkge1xuICAgIHJldHVybiBHZW9ncmFwaGljQ29udGV4dC5hZGRBYnN0cmFjdEVsZW1lbnQoY29udGV4dCwgbm9kZSwgYnVpbGRpbmdOYW1lKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NwaW5hbENvbnRleHR9IGNvbnRleHQgLSBUaGUgQ29udGV4dCBnZW9ncmFwaGljXG4gICAqIEBwYXJhbSB7U3BpbmFsTm9kZX0gbm9kZSAtIFRoZSBwYXJlbnQgTm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmxvb3JOYW1lIC0gdGhlIGZsb29yIE5hbWVcbiAgICovXG4gIGFkZEZsb29yKGNvbnRleHQsIG5vZGUsIGZsb29yTmFtZSkge1xuICAgIHJldHVybiBHZW9ncmFwaGljQ29udGV4dC5hZGRBYnN0cmFjdEVsZW1lbnQoY29udGV4dCwgbm9kZSwgZmxvb3JOYW1lKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NwaW5hbENvbnRleHR9IGNvbnRleHQgLSBUaGUgQ29udGV4dCBnZW9ncmFwaGljXG4gICAqIEBwYXJhbSB7U3BpbmFsTm9kZX0gbm9kZSAtIFRoZSBwYXJlbnQgTm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gem9uZU5hbWUgLSBab25lIG5hbWVcbiAgICovXG4gIGFkZFpvbmUoY29udGV4dCwgbm9kZSwgem9uZU5hbWUpIHtcbiAgICByZXR1cm4gR2VvZ3JhcGhpY0NvbnRleHQuYWRkQWJzdHJhY3RFbGVtZW50KGNvbnRleHQsIG5vZGUsIHpvbmVOYW1lKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NwaW5hbENvbnRleHR9IGNvbnRleHQgLSBUaGUgQ29udGV4dCBnZW9ncmFwaGljXG4gICAqIEBwYXJhbSB7U3BpbmFsTm9kZX0gbm9kZSAtIFRoZSBwYXJlbnQgTm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vbU5hbWUgLSBSb29tIE5hbWVcbiAgICovXG4gIGFkZFJvb20oY29udGV4dCwgbm9kZSwgcm9vbU5hbWUpIHtcbiAgICByZXR1cm4gR2VvZ3JhcGhpY0NvbnRleHQuYWRkQWJzdHJhY3RFbGVtZW50KGNvbnRleHQsIG5vZGUsIHJvb21OYW1lKTtcbiAgfSxcblxuICAvKipcbiAgICogaXQgdXNlcyBiaW1PYmplY3Qgc2VydmljZSB0byBhZGQgYWxsIGRiSWRzIHBhc3NlZCBhcyBwYXJhbWV0ZXJzLlxuICAgKiB0aGUgcGFyYW1ldGVyIGRiSWRzIGNhbiBiZSBhIHNpbXBsZSBkYklkcyBvciBhIGxpc3Qgb2YgZGJJZHMuXG4gICAqIEBwYXJhbSB7U3BpbmFsQ29udGV4dH0gY29udGV4dCAtIFRoZSBDb250ZXh0IGdlb2dyYXBoaWNcbiAgICogQHBhcmFtIHtTcGluYWxOb2RlfSBub2RlIC0gVGhlIHBhcmVudCBOb2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyIHwgQXJyYXk8TnVtYmVyPn0gZGJJZHMgLSBDYW4gYmVcbiAgICovXG4gIGFkZEJpbUVsZW1lbnQoY29udGV4dCwgbm9kZSwgZGJJZHMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGJJZHMpKSBkYklkcyA9IFtkYklkc107XG5cblxuICAgIC8vIGxlIGJpbU9iamVjdFNlcnZpY2VcbiAgICBsZXQgYyA9IFNwaW5hbEdyYXBoU2VydmljZS5nZXRSZWFsTm9kZShjb250ZXh0LmlkLmdldCgpKTtcbiAgICBsZXQgbiA9IFNwaW5hbEdyYXBoU2VydmljZS5nZXRSZWFsTm9kZShub2RlLmlkLmdldCgpKTtcblxuICAgIGRiSWRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBiaW1vYmpTZXJ2aWNlLmFkZEJJTU9iamVjdChjLCBuLCBlbGVtZW50LmRiSWQsIGVsZW1lbnQubmFtZSk7XG4gICAgfSk7XG4gIH0sXG5cblxuICBfZ2V0UmVmZXJlbmNlQ29udGV4dE5hbWUobm9kZUlkKSB7XG4gICAgbGV0IG5vZGUgPSBTcGluYWxHcmFwaFNlcnZpY2UuZ2V0SW5mbyhub2RlSWQpO1xuXG4gICAgc3dpdGNoIChub2RlLnR5cGUuZ2V0KCkpIHtcbiAgICAgIGNhc2UgY29uc3RhbnRzLlNJVEVfVFlQRTpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBjb25zdGFudHMuU0lURV9SRUZFUkVOQ0VfQ09OVEVYVCxcbiAgICAgICAgICByZWxhdGlvbjogY29uc3RhbnRzLlNJVEVfUkVMQVRJT05cbiAgICAgICAgfTtcbiAgICAgIGNhc2UgY29uc3RhbnRzLkJVSUxESU5HX1RZUEU6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogY29uc3RhbnRzLkJVSUxESU5HX1JFRkVSRU5DRV9DT05URVhULFxuICAgICAgICAgIHJlbGF0aW9uOiBjb25zdGFudHMuQlVJTERJTkdfUkVMQVRJT05cbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBjb25zdGFudHMuRkxPT1JfVFlQRTpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBjb25zdGFudHMuRkxPT1JfUkVGRVJFTkNFX0NPTlRFWFQsXG4gICAgICAgICAgcmVsYXRpb246IGNvbnN0YW50cy5GTE9PUl9SRUxBVElPTlxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIGNvbnN0YW50cy5aT05FX1RZUEU6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogY29uc3RhbnRzLlpPTkVfUkVGRVJFTkNFX0NPTlRFWFQsXG4gICAgICAgICAgcmVsYXRpb246IGNvbnN0YW50cy5aT05FX1JFTEFUSU9OXG4gICAgICAgIH07XG5cbiAgICAgIGNhc2UgY29uc3RhbnRzLlJPT01fVFlQRTpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBjb25zdGFudHMuUk9PTV9SRUZFUkVOQ0VfQ09OVEVYVCxcbiAgICAgICAgICByZWxhdGlvbjogY29uc3RhbnRzLlJPT01fUkVMQVRJT05cbiAgICAgICAgfTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBub2RlSWRcbiAgICovXG4gIGFkZFRvUmVmZXJlbmNlQ29udGV4dChub2RlSWQpIHtcbiAgICBsZXQgb2JqID0gdGhpcy5fZ2V0UmVmZXJlbmNlQ29udGV4dE5hbWUobm9kZUlkKTtcblxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBsZXQgY29udGV4dCA9IFNwaW5hbEdyYXBoU2VydmljZS5nZXRDb250ZXh0KG9iai5uYW1lKTtcblxuICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cbiAgICAgICAgcmV0dXJuIFNwaW5hbEdyYXBoU2VydmljZS5hZGRDaGlsZChjb250ZXh0LmluZm8uaWQuZ2V0KCksIG5vZGVJZCxcbiAgICAgICAgICBvYmoucmVsYXRpb24sXG4gICAgICAgICAgU1BJTkFMX1JFTEFUSU9OX0xTVF9QVFJfVFlQRSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTcGluYWxHcmFwaFNlcnZpY2UuYWRkQ29udGV4dChvYmoubmFtZSwgb2JqLm5hbWUucmVwbGFjZShcbiAgICAgICAgXCIuXCIsIFwiXCIpLCBuZXcgTW9kZWwoe1xuICAgICAgICBuYW1lOiBvYmoubmFtZVxuICAgICAgfSkpLnRoZW4oYyA9PiB7XG4gICAgICAgIHJldHVybiBTcGluYWxHcmFwaFNlcnZpY2UuYWRkQ2hpbGQoYy5pbmZvLmlkLmdldCgpLCBub2RlSWQsXG4gICAgICAgICAgb2JqLnJlbGF0aW9uLFxuICAgICAgICAgIFNQSU5BTF9SRUxBVElPTl9MU1RfUFRSX1RZUEUpO1xuICAgICAgfSk7XG5cblxuICAgIH1cblxuICB9LFxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dElkXG4gICAqL1xuICBhZGRDb250ZXh0VG9SZWZlcmVuY2UoY29udGV4dElkKSB7XG4gICAgbGV0IGNvbnRleHQgPSBTcGluYWxHcmFwaFNlcnZpY2UuZ2V0UmVhbE5vZGUoY29udGV4dElkKTtcblxuICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIGNvbnRleHQuZm9yRWFjaChjb25zdGFudHMuR0VPR1JBUEhJQ19SRUxBVElPTlMsIChub2RlKSA9PiB7XG4gICAgICAgIFNwaW5hbEdyYXBoU2VydmljZS5fYWRkTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5hZGRUb1JlZmVyZW5jZUNvbnRleHQobm9kZS5pbmZvLmlkLmdldCgpKTtcbiAgICAgIH0pXG4gICAgfVxuXG4gIH1cblxufTtcblxuZXhwb3J0IGRlZmF1bHQgR2VvZ3JhcGhpY0NvbnRleHQ7Il19