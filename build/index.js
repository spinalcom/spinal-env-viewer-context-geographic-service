"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spinalEnvViewerGraphService = require("spinal-env-viewer-graph-service");

var _spinalModelsBuildingElements = require("spinal-models-building-elements");

var _constants = require("./constants");

var constants = _interopRequireWildcard(_constants);

var _spinalCoreConnectorjs_type = require("spinal-core-connectorjs_type");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// import bimobjService from 'spinal-env-viewer-plugin-bimobjectservice';

const bimobjService = window.spinal.BimObjectService;

const GeographicContext = {
  constants: constants,

  /**
   * Returns the child type of the type given as parameter.
   * @param {string} parentType
   * @return {string} Child type
   */
  getChildType(parentType) {
    let parentTypeIndex = constants.GEOGRAPHIC_TYPES_ORDER.indexOf(parentType);

    if (parentTypeIndex === -1) {
      return "";
    }

    return constants.GEOGRAPHIC_TYPES_ORDER[parentTypeIndex + 1];
  },

  /**
   * It Takes as parameter a context name, returns true if a context with the same name does not exist, else returns false.
   * @param {string} contextName
   * @returns {Boolean}
   */
  createContext(contextName) {
    if (typeof contextName !== "string") {
      throw Error("contextName must be a string");
    }

    const context = _spinalEnvViewerGraphService.SpinalGraphService.getContext(contextName);

    if (typeof context !== "undefined") return false;

    _spinalEnvViewerGraphService.SpinalGraphService.addContext(contextName, constants.CONTEXT_TYPE, new _spinalModelsBuildingElements.AbstractElement(contextName));

    return true;
  },

  /**
   * This method takes as parameters a context (SpinalContext), a parent node (must be a SpinalNode) and a string representing the abstract element type;
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {string} elementName - The AbstactElement Name
   * @returns {Boolean}
   */
  addAbstractElement(context, node, elementName) {
    const parentType = node.type.get();
    const childType = this.getChildType(parentType);

    if (!childType) {
      throw Error(`${parentType} is not a valid type in geographical context`);
    }

    const childRelation = constants.MAP_TYPE_RELATION.get(childType);

    const childNode = _spinalEnvViewerGraphService.SpinalGraphService.createNode({
      name: elementName,
      type: childType
    }, new _spinalModelsBuildingElements.AbstractElement(elementName));
    _spinalEnvViewerGraphService.SpinalGraphService.addChildInContext(node.id.get(), childNode, context.id.get(), childRelation, _spinalEnvViewerGraphService.SPINAL_RELATION_TYPE);

    this.addToReferenceContext(childNode);

    return true;
  },

  /**
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {string} buildingName - Building Name
   */
  addBuilding(context, node, buildingName) {
    return GeographicContext.addAbstractElement(context, node, buildingName);
  },

  /**
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {string} floorName - the floor Name
   */
  addFloor(context, node, floorName) {
    return GeographicContext.addAbstractElement(context, node, floorName);
  },

  /**
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {string} zoneName - Zone name
   */
  addZone(context, node, zoneName) {
    return GeographicContext.addAbstractElement(context, node, zoneName);
  },

  /**
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {string} roomName - Room Name
   */
  addRoom(context, node, roomName) {
    return GeographicContext.addAbstractElement(context, node, roomName);
  },

  /**
   * it uses bimObject service to add all dbIds passed as parameters.
   * the parameter dbIds can be a simple dbIds or a list of dbIds.
   * @param {SpinalContext} context - The Context geographic
   * @param {SpinalNode} node - The parent Node
   * @param {Number | Array<Number>} dbIds - Can be
   */
  addBimElement(context, node, dbIds, model) {

    if (!Array.isArray(dbIds)) dbIds = [dbIds];

    // le bimObjectService
    // let c = SpinalGraphService.getRealNode(context.id.get());
    // let n = SpinalGraphService.getRealNode(node.id.get());

    let contextId = context.id.get();
    let parentId = node.id.get();

    dbIds.forEach(element => {
      // bimobjService.addBIMObject(c, n, element.dbId, element.name);
      window.spinal.BimObjectService.addBIMObject(contextId, parentId, element.dbId, element.name, model);
    });
  },

  _getReferenceContextName(nodeId) {
    let node = _spinalEnvViewerGraphService.SpinalGraphService.getInfo(nodeId);

    switch (node.type.get()) {
      case constants.SITE_TYPE:
        return {
          name: constants.SITE_REFERENCE_CONTEXT,
          relation: constants.SITE_RELATION
        };
      case constants.BUILDING_TYPE:
        return {
          name: constants.BUILDING_REFERENCE_CONTEXT,
          relation: constants.BUILDING_RELATION
        };

      case constants.FLOOR_TYPE:
        return {
          name: constants.FLOOR_REFERENCE_CONTEXT,
          relation: constants.FLOOR_RELATION
        };

      case constants.ZONE_TYPE:
        return {
          name: constants.ZONE_REFERENCE_CONTEXT,
          relation: constants.ZONE_RELATION
        };

      case constants.ROOM_TYPE:
        return {
          name: constants.ROOM_REFERENCE_CONTEXT,
          relation: constants.ROOM_RELATION
        };

      default:
        return undefined;
    }
  },

  /**
   *
   * @param {string} nodeId
   */
  addToReferenceContext(nodeId) {
    let obj = this._getReferenceContextName(nodeId);

    if (typeof obj !== "undefined") {
      let context = _spinalEnvViewerGraphService.SpinalGraphService.getContext(obj.name);

      if (typeof context !== "undefined") {

        return _spinalEnvViewerGraphService.SpinalGraphService.addChild(context.info.id.get(), nodeId, obj.relation, _spinalEnvViewerGraphService.SPINAL_RELATION_LST_PTR_TYPE);
      }

      return _spinalEnvViewerGraphService.SpinalGraphService.addContext(obj.name, obj.name.replace(".", ""), new _spinalCoreConnectorjs_type.Model({
        name: obj.name
      })).then(c => {
        return _spinalEnvViewerGraphService.SpinalGraphService.addChild(c.info.id.get(), nodeId, obj.relation, _spinalEnvViewerGraphService.SPINAL_RELATION_LST_PTR_TYPE);
      });
    }
  },

  /**
   *
   * @param {string} contextId
   */
  addContextToReference(contextId) {
    let context = _spinalEnvViewerGraphService.SpinalGraphService.getRealNode(contextId);

    if (typeof context !== "undefined") {
      return context.forEach(constants.GEOGRAPHIC_RELATIONS, node => {
        _spinalEnvViewerGraphService.SpinalGraphService._addNode(node);
        this.addToReferenceContext(node.info.id.get());
      });
    }
  }

};

exports.default = GeographicContext;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJjb25zdGFudHMiLCJiaW1vYmpTZXJ2aWNlIiwid2luZG93Iiwic3BpbmFsIiwiQmltT2JqZWN0U2VydmljZSIsIkdlb2dyYXBoaWNDb250ZXh0IiwiZ2V0Q2hpbGRUeXBlIiwicGFyZW50VHlwZSIsInBhcmVudFR5cGVJbmRleCIsIkdFT0dSQVBISUNfVFlQRVNfT1JERVIiLCJpbmRleE9mIiwiY3JlYXRlQ29udGV4dCIsImNvbnRleHROYW1lIiwiRXJyb3IiLCJjb250ZXh0IiwiU3BpbmFsR3JhcGhTZXJ2aWNlIiwiZ2V0Q29udGV4dCIsImFkZENvbnRleHQiLCJDT05URVhUX1RZUEUiLCJBYnN0cmFjdEVsZW1lbnQiLCJhZGRBYnN0cmFjdEVsZW1lbnQiLCJub2RlIiwiZWxlbWVudE5hbWUiLCJ0eXBlIiwiZ2V0IiwiY2hpbGRUeXBlIiwiY2hpbGRSZWxhdGlvbiIsIk1BUF9UWVBFX1JFTEFUSU9OIiwiY2hpbGROb2RlIiwiY3JlYXRlTm9kZSIsIm5hbWUiLCJhZGRDaGlsZEluQ29udGV4dCIsImlkIiwiU1BJTkFMX1JFTEFUSU9OX1RZUEUiLCJhZGRUb1JlZmVyZW5jZUNvbnRleHQiLCJhZGRCdWlsZGluZyIsImJ1aWxkaW5nTmFtZSIsImFkZEZsb29yIiwiZmxvb3JOYW1lIiwiYWRkWm9uZSIsInpvbmVOYW1lIiwiYWRkUm9vbSIsInJvb21OYW1lIiwiYWRkQmltRWxlbWVudCIsImRiSWRzIiwibW9kZWwiLCJBcnJheSIsImlzQXJyYXkiLCJjb250ZXh0SWQiLCJwYXJlbnRJZCIsImZvckVhY2giLCJlbGVtZW50IiwiYWRkQklNT2JqZWN0IiwiZGJJZCIsIl9nZXRSZWZlcmVuY2VDb250ZXh0TmFtZSIsIm5vZGVJZCIsImdldEluZm8iLCJTSVRFX1RZUEUiLCJTSVRFX1JFRkVSRU5DRV9DT05URVhUIiwicmVsYXRpb24iLCJTSVRFX1JFTEFUSU9OIiwiQlVJTERJTkdfVFlQRSIsIkJVSUxESU5HX1JFRkVSRU5DRV9DT05URVhUIiwiQlVJTERJTkdfUkVMQVRJT04iLCJGTE9PUl9UWVBFIiwiRkxPT1JfUkVGRVJFTkNFX0NPTlRFWFQiLCJGTE9PUl9SRUxBVElPTiIsIlpPTkVfVFlQRSIsIlpPTkVfUkVGRVJFTkNFX0NPTlRFWFQiLCJaT05FX1JFTEFUSU9OIiwiUk9PTV9UWVBFIiwiUk9PTV9SRUZFUkVOQ0VfQ09OVEVYVCIsIlJPT01fUkVMQVRJT04iLCJ1bmRlZmluZWQiLCJvYmoiLCJhZGRDaGlsZCIsImluZm8iLCJTUElOQUxfUkVMQVRJT05fTFNUX1BUUl9UWVBFIiwicmVwbGFjZSIsIk1vZGVsIiwidGhlbiIsImMiLCJhZGRDb250ZXh0VG9SZWZlcmVuY2UiLCJnZXRSZWFsTm9kZSIsIkdFT0dSQVBISUNfUkVMQVRJT05TIiwiX2FkZE5vZGUiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztBQUtBOztBQVFBOztJQUFZQSxTOztBQUNaOzs7O0FBTEE7O0FBRUEsTUFBTUMsZ0JBQWdCQyxPQUFPQyxNQUFQLENBQWNDLGdCQUFwQzs7QUFPQSxNQUFNQyxvQkFBb0I7QUFDeEJMLGFBQVdBLFNBRGE7O0FBR3hCOzs7OztBQUtBTSxlQUFhQyxVQUFiLEVBQXlCO0FBQ3ZCLFFBQUlDLGtCQUFrQlIsVUFBVVMsc0JBQVYsQ0FBaUNDLE9BQWpDLENBQ3BCSCxVQURvQixDQUF0Qjs7QUFHQSxRQUFJQyxvQkFBb0IsQ0FBQyxDQUF6QixFQUE0QjtBQUMxQixhQUFPLEVBQVA7QUFDRDs7QUFFRCxXQUFPUixVQUFVUyxzQkFBVixDQUFpQ0Qsa0JBQWtCLENBQW5ELENBQVA7QUFDRCxHQWpCdUI7O0FBbUJ4Qjs7Ozs7QUFLQUcsZ0JBQWNDLFdBQWQsRUFBMkI7QUFDekIsUUFBSSxPQUFPQSxXQUFQLEtBQXVCLFFBQTNCLEVBQXFDO0FBQ25DLFlBQU1DLE1BQ0osOEJBREksQ0FBTjtBQUVEOztBQUVELFVBQU1DLFVBQVVDLGdEQUFtQkMsVUFBbkIsQ0FBOEJKLFdBQTlCLENBQWhCOztBQUVBLFFBQUksT0FBT0Us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QUFSLENBQWE1QyxFQUFiLENBQWdCUixHQUFoQixFQUE1QixFQUFtRCtCLE1BQW5ELEVBQ0xtQixJQUFJZixRQURDLEVBRUxrQix5REFGSyxDQUFQO0FBR0Q7O0FBRUQsYUFBTzlELGdEQUFtQkUsVUFBbkIsQ0FBOEJ5RCxJQUFJNUMsSUFBbEMsRUFBd0M0QyxJQUFJNUMsSUFBSixDQUFTZ0QsT0FBVCxDQUM3QyxHQUQ2QyxFQUN4QyxFQUR3QyxDQUF4QyxFQUNLLElBQUlDLGlDQUFKLENBQVU7QUFDcEJqRCxjQUFNNEMsSUFBSTVDO0FBRFUsT0FBVixDQURMLEVBR0hrRCxJQUhHLENBR0VDLEtBQUs7QUFDWixlQUFPbEUsZ0RBQW1CNEQsUUFBbkIsQ0FBNEJNLEVBQUVMLElBQUYsQ0FBTzVDLEVBQVAsQ0FBVVIsR0FBVixFQUE1QixFQUE2QytCLE1BQTdDLEVBQ0xtQixJQUFJZixRQURDLEVBRUxrQix5REFGSyxDQUFQO0FBR0QsT0FQTSxDQUFQO0FBVUQ7QUFFRixHQWpOdUI7O0FBbU54Qjs7OztBQUlBSyx3QkFBc0JsQyxTQUF0QixFQUFpQztBQUMvQixRQUFJbEMsVUFBVUMsZ0RBQW1Cb0UsV0FBbkIsQ0FBK0JuQyxTQUEvQixDQUFkOztBQUVBLFFBQUksT0FBT2xDLE9BQVAsS0FBbUIsV0FBdkIsRUFBb0M7QUFDbEMsYUFBT0EsUUFBUW9DLE9BQVIsQ0FBZ0JsRCxVQUFVb0Ysb0JBQTFCLEVBQWlEL0QsSUFBRCxJQUFVO0FBQy9ETix3REFBbUJzRSxRQUFuQixDQUE0QmhFLElBQTVCO0FBQ0EsYUFBS2EscUJBQUwsQ0FBMkJiLEtBQUt1RCxJQUFMLENBQVU1QyxFQUFWLENBQWFSLEdBQWIsRUFBM0I7QUFDRCxPQUhNLENBQVA7QUFJRDtBQUVGOztBQWpPdUIsQ0FBMUI7O2tCQXFPZW5CLGlCIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgU1BJTkFMX1JFTEFUSU9OX1RZUEUsXG4gIFNQSU5BTF9SRUxBVElPTl9MU1RfUFRSX1RZUEUsXG4gIFNwaW5hbEdyYXBoU2VydmljZVxufSBmcm9tIFwic3BpbmFsLWVudi12aWV3ZXItZ3JhcGgtc2VydmljZVwiO1xuaW1wb3J0IHtcbiAgQWJzdHJhY3RFbGVtZW50XG59IGZyb20gXCJzcGluYWwtbW9kZWxzLWJ1aWxkaW5nLWVsZW1lbnRzXCI7XG5cbi8vIGltcG9ydCBiaW1vYmpTZXJ2aWNlIGZyb20gJ3NwaW5hbC1lbnYtdmlld2VyLXBsdWdpbi1iaW1vYmplY3RzZXJ2aWNlJztcblxuY29uc3QgYmltb2JqU2VydmljZSA9IHdpbmRvdy5zcGluYWwuQmltT2JqZWN0U2VydmljZTtcblxuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gXCIuL2NvbnN0YW50c1wiO1xuaW1wb3J0IHtcbiAgTW9kZWxcbn0gZnJvbSBcInNwaW5hbC1jb3JlLWNvbm5lY3RvcmpzX3R5cGVcIjtcblxuY29uc3QgR2VvZ3JhcGhpY0NvbnRleHQgPSB7XG4gIGNvbnN0YW50czogY29uc3RhbnRzLFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaGlsZCB0eXBlIG9mIHRoZSB0eXBlIGdpdmVuIGFzIHBhcmFtZXRlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudFR5cGVcbiAgICogQHJldHVybiB7c3RyaW5nfSBDaGlsZCB0eXBlXG4gICAqL1xuICBnZXRDaGlsZFR5cGUocGFyZW50VHlwZSkge1xuICAgIGxldCBwYXJlbnRUeXBlSW5kZXggPSBjb25zdGFudHMuR0VPR1JBUEhJQ19UWVBFU19PUkRFUi5pbmRleE9mKFxuICAgICAgcGFyZW50VHlwZSk7XG5cbiAgICBpZiAocGFyZW50VHlwZUluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnN0YW50cy5HRU9HUkFQSElDX1RZUEVTX09SREVSW3BhcmVudFR5cGVJbmRleCArIDFdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJdCBUYWtlcyBhcyBwYXJhbWV0ZXIgYSBjb250ZXh0IG5hbWUsIHJldHVybnMgdHJ1ZSBpZiBhIGNvbnRleHQgd2l0aCB0aGUgc2FtZSBuYW1lIGRvZXMgbm90IGV4aXN0LCBlbHNlIHJldHVybnMgZmFsc2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0TmFtZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGNyZWF0ZUNvbnRleHQoY29udGV4dE5hbWUpIHtcbiAgICBpZiAodHlwZW9mIGNvbnRleHROYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJjb250ZXh0TmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRleHQgPSBTcGluYWxHcmFwaFNlcnZpY2UuZ2V0Q29udGV4dChjb250ZXh0TmFtZSk7XG5cbiAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcblxuXG4gICAgU3BpbmFsR3JhcGhTZXJ2aWNlLmFkZENvbnRleHQoY29udGV4dE5hbWUsXG4gICAgICBjb25zdGFudHMuQ09OVEVYVF9UWVBFLFxuICAgICAgbmV3IEFic3RyYWN0RWxlbWVudChjb250ZXh0TmFtZSkpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHRha2VzIGFzIHBhcmFtZXRlcnMgYSBjb250ZXh0IChTcGluYWxDb250ZXh0KSwgYSBwYXJlbnQgbm9kZSAobXVzdCBiZSBhIFNwaW5hbE5vZGUpIGFuZCBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGFic3RyYWN0IGVsZW1lbnQgdHlwZTtcbiAgICogQHBhcmFtIHtTcGluYWxDb250ZXh0fSBjb250ZXh0IC0gVGhlIENvbnRleHQgZ2VvZ3JhcGhpY1xuICAgKiBAcGFyYW0ge1NwaW5hbE5vZGV9IG5vZGUgLSBUaGUgcGFyZW50IE5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lIC0gVGhlIEFic3RhY3RFbGVtZW50IE5hbWVcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBhZGRBYnN0cmFjdEVsZW1lbnQoY29udGV4dCwgbm9kZSwgZWxlbWVudE5hbWUpIHtcbiAgICBjb25zdCBwYXJlbnRUeXBlID0gbm9kZS50eXBlLmdldCgpO1xuICAgIGNvbnN0IGNoaWxkVHlwZSA9IHRoaXMuZ2V0Q2hpbGRUeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKCFjaGlsZFR5cGUpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgJHtwYXJlbnRUeXBlfSBpcyBub3QgYSB2YWxpZCB0eXBlIGluIGdlb2dyYXBoaWNhbCBjb250ZXh0YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGlsZFJlbGF0aW9uID0gY29uc3RhbnRzLk1BUF9UWVBFX1JFTEFUSU9OLmdldChjaGlsZFR5cGUpO1xuXG4gICAgY29uc3QgY2hpbGROb2RlID0gU3BpbmFsR3JhcGhTZXJ2aWNlLmNyZWF0ZU5vZGUoe1xuICAgICAgICBuYW1lOiBlbGVtZW50TmFtZSxcbiAgICAgICAgdHlwZTogY2hpbGRUeXBlXG4gICAgICB9LFxuICAgICAgbmV3IEFic3RyYWN0RWxlbWVudChlbGVtZW50TmFtZSlcbiAgICApO1xuICAgIFNwaW5hbEdyYXBoU2VydmljZS5hZGRDaGlsZEluQ29udGV4dChub2RlLmlkLmdldCgpLCBjaGlsZE5vZGUsIGNvbnRleHQuaWRcbiAgICAgIC5nZXQoKSwgY2hpbGRSZWxhdGlvbiwgU1BJTkFMX1JFTEFUSU9OX1RZUEUpO1xuXG4gICAgdGhpcy5hZGRUb1JlZmVyZW5jZUNvbnRleHQoY2hpbGROb2RlKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NwaW5hbENvbnRleHR9IGNvbnRleHQgLSBUaGUgQ29udGV4dCBnZW9ncmFwaGljXG4gICAqIEBwYXJhbSB7U3BpbmFsTm9kZX0gbm9kZSAtIFRoZSBwYXJlbnQgTm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYnVpbGRpbmdOYW1lIC0gQnVpbGRpbmcgTmFtZVxuICAgKi9cbiAgYWRkQnVpbGRpbmcoY29udGV4dCwgbm9kZSwgYnVpbGRpbmdOYW1lKSB7XG4gICAgcmV0dXJuIEdlb2dyYXBoaWNDb250ZXh0LmFkZEFic3RyYWN0RWxlbWVudChjb250ZXh0LCBub2RlLCBidWlsZGluZ05hbWUpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3BpbmFsQ29udGV4dH0gY29udGV4dCAtIFRoZSBDb250ZXh0IGdlb2dyYXBoaWNcbiAgICogQHBhcmFtIHtTcGluYWxOb2RlfSBub2RlIC0gVGhlIHBhcmVudCBOb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbG9vck5hbWUgLSB0aGUgZmxvb3IgTmFtZVxuICAgKi9cbiAgYWRkRmxvb3IoY29udGV4dCwgbm9kZSwgZmxvb3JOYW1lKSB7XG4gICAgcmV0dXJuIEdlb2dyYXBoaWNDb250ZXh0LmFkZEFic3RyYWN0RWxlbWVudChjb250ZXh0LCBub2RlLCBmbG9vck5hbWUpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3BpbmFsQ29udGV4dH0gY29udGV4dCAtIFRoZSBDb250ZXh0IGdlb2dyYXBoaWNcbiAgICogQHBhcmFtIHtTcGluYWxOb2RlfSBub2RlIC0gVGhlIHBhcmVudCBOb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6b25lTmFtZSAtIFpvbmUgbmFtZVxuICAgKi9cbiAgYWRkWm9uZShjb250ZXh0LCBub2RlLCB6b25lTmFtZSkge1xuICAgIHJldHVybiBHZW9ncmFwaGljQ29udGV4dC5hZGRBYnN0cmFjdEVsZW1lbnQoY29udGV4dCwgbm9kZSwgem9uZU5hbWUpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3BpbmFsQ29udGV4dH0gY29udGV4dCAtIFRoZSBDb250ZXh0IGdlb2dyYXBoaWNcbiAgICogQHBhcmFtIHtTcGluYWxOb2RlfSBub2RlIC0gVGhlIHBhcmVudCBOb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb29tTmFtZSAtIFJvb20gTmFtZVxuICAgKi9cbiAgYWRkUm9vbShjb250ZXh0LCBub2RlLCByb29tTmFtZSkge1xuICAgIHJldHVybiBHZW9ncmFwaGljQ29udGV4dC5hZGRBYnN0cmFjdEVsZW1lbnQoY29udGV4dCwgbm9kZSwgcm9vbU5hbWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBpdCB1c2VzIGJpbU9iamVjdCBzZXJ2aWNlIHRvIGFkZCBhbGwgZGJJZHMgcGFzc2VkIGFzIHBhcmFtZXRlcnMuXG4gICAqIHRoZSBwYXJhbWV0ZXIgZGJJZHMgY2FuIGJlIGEgc2ltcGxlIGRiSWRzIG9yIGEgbGlzdCBvZiBkYklkcy5cbiAgICogQHBhcmFtIHtTcGluYWxDb250ZXh0fSBjb250ZXh0IC0gVGhlIENvbnRleHQgZ2VvZ3JhcGhpY1xuICAgKiBAcGFyYW0ge1NwaW5hbE5vZGV9IG5vZGUgLSBUaGUgcGFyZW50IE5vZGVcbiAgICogQHBhcmFtIHtOdW1iZXIgfCBBcnJheTxOdW1iZXI+fSBkYklkcyAtIENhbiBiZVxuICAgKi9cbiAgYWRkQmltRWxlbWVudChjb250ZXh0LCBub2RlLCBkYklkcywgbW9kZWwpIHtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShkYklkcykpIGRiSWRzID0gW2RiSWRzXTtcblxuXG4gICAgLy8gbGUgYmltT2JqZWN0U2VydmljZVxuICAgIC8vIGxldCBjID0gU3BpbmFsR3JhcGhTZXJ2aWNlLmdldFJlYWxOb2RlKGNvbnRleHQuaWQuZ2V0KCkpO1xuICAgIC8vIGxldCBuID0gU3BpbmFsR3JhcGhTZXJ2aWNlLmdldFJlYWxOb2RlKG5vZGUuaWQuZ2V0KCkpO1xuXG4gICAgbGV0IGNvbnRleHRJZCA9IGNvbnRleHQuaWQuZ2V0KCk7XG4gICAgbGV0IHBhcmVudElkID0gbm9kZS5pZC5nZXQoKTtcblxuICAgIGRiSWRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAvLyBiaW1vYmpTZXJ2aWNlLmFkZEJJTU9iamVjdChjLCBuLCBlbGVtZW50LmRiSWQsIGVsZW1lbnQubmFtZSk7XG4gICAgICB3aW5kb3cuc3BpbmFsLkJpbU9iamVjdFNlcnZpY2UuYWRkQklNT2JqZWN0KGNvbnRleHRJZCwgcGFyZW50SWQsXG4gICAgICAgIGVsZW1lbnQuZGJJZCxcbiAgICAgICAgZWxlbWVudC5uYW1lLCBtb2RlbClcbiAgICB9KTtcbiAgfSxcblxuXG4gIF9nZXRSZWZlcmVuY2VDb250ZXh0TmFtZShub2RlSWQpIHtcbiAgICBsZXQgbm9kZSA9IFNwaW5hbEdyYXBoU2VydmljZS5nZXRJbmZvKG5vZGVJZCk7XG5cbiAgICBzd2l0Y2ggKG5vZGUudHlwZS5nZXQoKSkge1xuICAgICAgY2FzZSBjb25zdGFudHMuU0lURV9UWVBFOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IGNvbnN0YW50cy5TSVRFX1JFRkVSRU5DRV9DT05URVhULFxuICAgICAgICAgICAgcmVsYXRpb246IGNvbnN0YW50cy5TSVRFX1JFTEFUSU9OXG4gICAgICAgIH07XG4gICAgICBjYXNlIGNvbnN0YW50cy5CVUlMRElOR19UWVBFOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IGNvbnN0YW50cy5CVUlMRElOR19SRUZFUkVOQ0VfQ09OVEVYVCxcbiAgICAgICAgICAgIHJlbGF0aW9uOiBjb25zdGFudHMuQlVJTERJTkdfUkVMQVRJT05cbiAgICAgICAgfTtcblxuICAgICAgY2FzZSBjb25zdGFudHMuRkxPT1JfVFlQRTpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBjb25zdGFudHMuRkxPT1JfUkVGRVJFTkNFX0NPTlRFWFQsXG4gICAgICAgICAgICByZWxhdGlvbjogY29uc3RhbnRzLkZMT09SX1JFTEFUSU9OXG4gICAgICAgIH07XG5cbiAgICAgIGNhc2UgY29uc3RhbnRzLlpPTkVfVFlQRTpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBjb25zdGFudHMuWk9ORV9SRUZFUkVOQ0VfQ09OVEVYVCxcbiAgICAgICAgICAgIHJlbGF0aW9uOiBjb25zdGFudHMuWk9ORV9SRUxBVElPTlxuICAgICAgICB9O1xuXG4gICAgICBjYXNlIGNvbnN0YW50cy5ST09NX1RZUEU6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogY29uc3RhbnRzLlJPT01fUkVGRVJFTkNFX0NPTlRFWFQsXG4gICAgICAgICAgICByZWxhdGlvbjogY29uc3RhbnRzLlJPT01fUkVMQVRJT05cbiAgICAgICAgfTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBub2RlSWRcbiAgICovXG4gIGFkZFRvUmVmZXJlbmNlQ29udGV4dChub2RlSWQpIHtcbiAgICBsZXQgb2JqID0gdGhpcy5fZ2V0UmVmZXJlbmNlQ29udGV4dE5hbWUobm9kZUlkKTtcblxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBsZXQgY29udGV4dCA9IFNwaW5hbEdyYXBoU2VydmljZS5nZXRDb250ZXh0KG9iai5uYW1lKTtcblxuICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cbiAgICAgICAgcmV0dXJuIFNwaW5hbEdyYXBoU2VydmljZS5hZGRDaGlsZChjb250ZXh0LmluZm8uaWQuZ2V0KCksIG5vZGVJZCxcbiAgICAgICAgICBvYmoucmVsYXRpb24sXG4gICAgICAgICAgU1BJTkFMX1JFTEFUSU9OX0xTVF9QVFJfVFlQRSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTcGluYWxHcmFwaFNlcnZpY2UuYWRkQ29udGV4dChvYmoubmFtZSwgb2JqLm5hbWUucmVwbGFjZShcbiAgICAgICAgXCIuXCIsIFwiXCIpLCBuZXcgTW9kZWwoe1xuICAgICAgICBuYW1lOiBvYmoubmFtZVxuICAgICAgfSkpLnRoZW4oYyA9PiB7XG4gICAgICAgIHJldHVybiBTcGluYWxHcmFwaFNlcnZpY2UuYWRkQ2hpbGQoYy5pbmZvLmlkLmdldCgpLCBub2RlSWQsXG4gICAgICAgICAgb2JqLnJlbGF0aW9uLFxuICAgICAgICAgIFNQSU5BTF9SRUxBVElPTl9MU1RfUFRSX1RZUEUpO1xuICAgICAgfSk7XG5cblxuICAgIH1cblxuICB9LFxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dElkXG4gICAqL1xuICBhZGRDb250ZXh0VG9SZWZlcmVuY2UoY29udGV4dElkKSB7XG4gICAgbGV0IGNvbnRleHQgPSBTcGluYWxHcmFwaFNlcnZpY2UuZ2V0UmVhbE5vZGUoY29udGV4dElkKTtcblxuICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIGNvbnRleHQuZm9yRWFjaChjb25zdGFudHMuR0VPR1JBUEhJQ19SRUxBVElPTlMsIChub2RlKSA9PiB7XG4gICAgICAgIFNwaW5hbEdyYXBoU2VydmljZS5fYWRkTm9kZShub2RlKTtcbiAgICAgICAgdGhpcy5hZGRUb1JlZmVyZW5jZUNvbnRleHQobm9kZS5pbmZvLmlkLmdldCgpKTtcbiAgICAgIH0pXG4gICAgfVxuXG4gIH1cblxufTtcblxuZXhwb3J0IGRlZmF1bHQgR2VvZ3JhcGhpY0NvbnRleHQ7Il19